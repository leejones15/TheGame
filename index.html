<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>THE GAME</title>
<style>
  :root{
    --board-size: 620px;
    --cell: calc(var(--board-size) / 6);

    /* Light theme palette */
    --bg: #f6f8fb;            /* page background */
    --panel: #ffffff;         /* side panel / cards */
    --panel-border: #d1d5db;  /* panel & grid borders */
    --muted: #374151;         /* subdued text */
    --text: #111827;          /* primary text */
    --accent: #2563eb;        /* links / accents (blue) */

    /* Piece tints (high contrast) */
    --human1: #60a5fa;  /* blue-400 */
    --human2: #2563eb;  /* blue-600 */
    --cpu1:   #f87171;  /* red-400 */
    --cpu2:   #b91c1c;  /* red-700 */

    --grain1: rgba(0,0,0,.035);
    --grain2: rgba(0,0,0,.055);

    /* Gate overlays (slightly stronger for visibility on light cells) */
    --gate-green: rgba(16,185,129,0.28);
    --gate-orange: rgba(249,115,22,0.28);
    --gate-purple: rgba(168,85,247,0.28);

    /* Selection/possible-move highlight */
    --hl: rgba(37,99,235,.70);

    /* Board cells */
    --cell-a: #ffffff;  /* light square */
    --cell-b: #eef2f7;  /* slightly tinted square */
    --cell-border: #cbd5e1; /* slate-300 */
  }

  html,body{
    height:100%; margin:0;
    background:var(--bg); color:var(--text);
    font-family: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial,"Noto Sans",sans-serif
  }
  .app{max-width:1120px;margin:24px auto;padding:16px;display:grid;grid-template-columns: var(--board-size) 1fr;gap:18px}

  .board-wrap{position:relative;padding-left:34px;padding-top:26px}
  .board{
    width:var(--board-size);height:var(--board-size);
    display:grid;grid-template-columns:repeat(6,1fr);grid-template-rows:repeat(6,1fr);
    background:#e2e8f0; /* light slate backing behind cells */
    border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.12);
    overflow:visible;border:1px solid var(--panel-border);position:relative
  }
  .cell{position:relative;border:1px solid var(--cell-border);background:var(--cell-a)}
  .cell:nth-child(odd){background:var(--cell-b)}
  .cell[data-gatecolor="green"]::after{content:"";position:absolute;inset:0;background:var(--gate-green)}
  .cell[data-gatecolor="orange"]::after{content:"";position:absolute;inset:0;background:var(--gate-orange)}
  .cell[data-gatecolor="purple"]::after{content:"";position:absolute;inset:0;background:var(--gate-purple)}

  .coords{position:absolute;inset:0;pointer-events:none}
  .coord{position:absolute;font-size:12px;color:var(--muted);font-weight:600}
  .coord.top{transform:translate(-50%,-8px)}
  .coord.left{transform:translate(-8px,-50%)}

  /* Pieces (keep 3D styling, just brighter tints) */
  .piece{
    position:absolute;display:flex;align-items:center;justify-content:center;color:#fff;user-select:none;cursor:pointer;
    transition:left .28s ease, top .28s ease, transform .18s ease, box-shadow .22s ease, filter .24s ease; overflow:hidden;
    border:1px solid rgba(0,0,0,.08)
  }
  .piece::before{content:"";position:absolute;inset:0;background:radial-gradient(140% 110% at 25% 15%, rgba(255,255,255,.28), rgba(255,255,255,0) 55%);mix-blend-mode:screen;pointer-events:none}
  .piece::after{content:"";position:absolute;left:8%;right:8%;bottom:-8%;height:20%;background:radial-gradient(70% 100% at 50% 0%, rgba(0,0,0,.25), rgba(0,0,0,0));filter:blur(4px);pointer-events:none}
  .piece.human{
    background:
      radial-gradient(120% 100% at 25% 20%, rgba(255,255,255,.18), rgba(255,255,255,0) 55%),
      repeating-linear-gradient(24deg, var(--grain1) 0 2px, var(--grain2) 2px 5px),
      linear-gradient(145deg, var(--human1), var(--human2));
    background-blend-mode: overlay, multiply, normal;
    box-shadow: 0 10px 20px rgba(0,0,0,.18), inset 0 -10px 18px rgba(0,0,0,.10), inset 0 1px 0 rgba(255,255,255,.35);
    filter: saturate(1.05) brightness(1.02);
  }
  .piece.cpu{
    background:
      radial-gradient(120% 100% at 25% 20%, rgba(255,255,255,.16), rgba(255,255,255,0) 55%),
      repeating-linear-gradient(24deg, var(--grain1) 0 2px, var(--grain2) 2px 5px),
      linear-gradient(145deg, var(--cpu1), var(--cpu2));
    background-blend-mode: overlay, multiply, normal;
    box-shadow: 0 10px 20px rgba(0,0,0,.18), inset 0 -10px 18px rgba(0,0,0,.10), inset 0 1px 0 rgba(255,255,255,.28);
    filter: saturate(1.05) brightness(1.02);
  }
  .piece.selected{outline:3px solid var(--hl);outline-offset:2px;transform:translateY(-1px) scale(1.02)}
  .piece.home{opacity:.98; cursor:default; pointer-events:none; filter:saturate(95%)}

  @keyframes cpuMovePulse{0%{transform:translateY(0) scale(1)}50%{transform:translateY(-2px) scale(1.04)}100%{transform:translateY(0) scale(1)}}
  .piece.cpu-anim{box-shadow:0 0 0 3px rgba(37,99,235,.24), 0 12px 30px rgba(0,0,0,.20), inset 0 -10px 18px rgba(0,0,0,.10), inset 0 1px 0 rgba(255,255,255,.18); animation: cpuMovePulse .36s ease}

  /* Shapes */
  .shape-circle{border-radius:50%}
  .shape-square{border-radius:12px}
  .shape-triangle{clip-path: polygon(50% 8%, 92% 92%, 8% 92%)}
  .shape-diamond{clip-path: polygon(50% 6%, 94% 50%, 50% 94%, 6% 50%)}

  /* Move overlays */
  .dest{
    position:absolute;border-radius:12px;border:3px dashed var(--hl);
    background:rgba(37,99,235,.10);cursor:pointer; z-index:50
  }
  .dest:hover{background:rgba(37,99,235,.18)}

  .off-btn{
    position:absolute;z-index:60;padding:8px 10px;border-radius:10px;border:1px solid var(--panel-border);
    background:var(--accent);color:#ffffff;font-weight:800;cursor:pointer;box-shadow:0 6px 16px rgba(37,99,235,.28)
  }

  /* Right panel */
  .panel{
    background:var(--panel);border:1px solid var(--panel-border);border-radius:16px;
    box-shadow:0 10px 30px rgba(0,0,0,.08);padding:16px;display:flex;flex-direction:column;gap:12px
  }
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .btn{
    padding:8px 10px;border-radius:10px;border:1px solid var(--panel-border);
    background:var(--panel);color:var(--text);cursor:pointer
  }

  .moves{
    height:500px;overflow:auto;border:1px dashed var(--panel-border);border-radius:12px;padding:8px;
    background:#f8fafc;font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace
  }
  .mv{display:flex;align-items:center;gap:8px;padding:6px 8px;border-radius:8px}
  .mv:nth-child(odd){background:#eef2ff}
  .sym{display:inline-block;width:16px;height:16px;line-height:16px;text-align:center;border-radius:3px;font-size:12px}
  .sym.h{color:#1e3a8a}   /* human marker */
  .sym.c{color:#991b1b}   /* cpu marker */
  .mv .who{font-size:11px;color:var(--muted);margin-right:4px}
  .mv .path{font-weight:700;color:#0f172a}

  .toast{
    position:fixed;left:50%;bottom:24px;transform:translateX(-50%);
    background:var(--panel);color:var(--text);border:1px solid var(--panel-border);
    padding:10px 14px;border-radius:12px;opacity:0;pointer-events:none;transition:opacity .2s ease; box-shadow:0 8px 24px rgba(0,0,0,.10)
  }
  .toast.show{opacity:1}

  /* Ripple marker for CPU moves */
  @keyframes ripple{0%{transform:scale(.85);opacity:.9}100%{transform:scale(1.12);opacity:0}}
  .ripple{position:absolute;border:2px solid var(--accent);border-radius:12px;opacity:.85;animation:ripple .5s ease-out forwards;pointer-events:none; z-index:40}
</style>

</head>
<body>
<div class="app">
  <div class="board-wrap">
    <div id="board" class="board" aria-label="6x6 board"></div>
    <div id="coords" class="coords" aria-hidden="true"></div>
    <button id="offBtn" class="off-btn" style="display:none">OFF</button>
  </div>
  <div class="panel">
    <div class="row"><button class="btn" id="resetBtn">Reset</button></div>
    <div id="moves" class="moves" aria-live="polite"></div>
  </div>
</div>
<div id="toast" class="toast" role="status" aria-live="polite"></div>
<script>
(function(){
  // ====== CONFIG ======
  const N = 6; // board size
  const HUMAN_DIR = {back:-1}; // human "backward" = north (r-1)
  const CPU_DIR = {back:+1};   // cpu "backward" = east (c+1)
  const LETTERS = ['A','B','C','D','E','F'];

  const SHAPE_TO_COLOR = { circle:'green', square:'orange', triangle:'purple' }; // blocker has no color/gate
  const COLORS = ['green','orange','purple'];
  const SHAPE_SYM = { circle:'●', square:'■', triangle:'▲', blocker:'◆' };

  // ====== UTIL ======
  const idx = (r,c)=> (r*N+c);
  const toRC = (i)=> [Math.floor(i/N), i%N];
  const inBounds = (r,c)=> r>=0 && r<N && c>=0 && c<N;
  const coord = (i)=>{ const [r,c]=toRC(i); return `${LETTERS[c]}${r+1}`; };
  const MID3 = [Math.floor(N/2)-1, Math.floor(N/2), Math.floor(N/2)+1]; // [2,3,4] for N=6
  const manhattan = (a,b)=>{ const [r1,c1]=toRC(a), [r2,c2]=toRC(b); return Math.abs(r1-r2)+Math.abs(c1-c2); };

  function findPieceAt(i){ const p = PIECES.find(p=> state.pos[p.id]===i ); return p? p.id : null; }

  // ====== STATE / DOM ======
  const boardEl = document.getElementById('board');
  const coordsEl = document.getElementById('coords');
  const toastEl = document.getElementById('toast');
  const offBtn  = document.getElementById('offBtn');
  const resetBtn= document.getElementById('resetBtn');
  const movesEl = document.getElementById('moves');

  const cells = [];
  for(let r=0;r<N;r++){
    for(let c=0;c<N;c++){
      const cell = document.createElement('div');
      cell.className = 'cell'; cell.dataset.r=r; cell.dataset.c=c; cell.dataset.i=idx(r,c);
      // color the three South gates (human exits) and three West gates (cpu exits)
      if(r===N-1 && MID3.includes(c)){
        const color = COLORS[MID3.indexOf(c)];
        cell.dataset.gatecolor = color;
      }
      if(c===0 && MID3.includes(r)){
        const color = COLORS[MID3.indexOf(r)];
        cell.dataset.gatecolor = cell.dataset.gatecolor? cell.dataset.gatecolor : color;
      }
      boardEl.appendChild(cell); cells.push(cell);
    }
  }

  // Build axis labels
  function buildCoords(){
    coordsEl.innerHTML='';
    const cw = boardEl.clientWidth/6, ch = boardEl.clientHeight/6;
    // top letters A-F
    for(let c=0;c<6;c++){
      const span = document.createElement('div');
      span.className='coord top';
      span.style.left = (boardEl.offsetLeft + cw*c + cw/2) + 'px';
      span.style.top  = (boardEl.offsetTop - 6) + 'px';
      span.textContent = LETTERS[c];
      coordsEl.appendChild(span);
    }
    // left numbers 1-6
    for(let r=0;r<6;r++){
      const span = document.createElement('div');
      span.className='coord left';
      span.style.left = (boardEl.offsetLeft - 6) + 'px';
      span.style.top  = (boardEl.offsetTop + ch*r + ch/2) + 'px';
      span.textContent = (r+1);
      coordsEl.appendChild(span);
    }
  }

  // Gate lookup per side/color -> cell index
  const HUMAN_GATES = { green: idx(N-1, MID3[0]), orange: idx(N-1, MID3[1]), purple: idx(N-1, MID3[2]) };
  const CPU_GATES   = { green: idx(MID3[0], 0),   orange: idx(MID3[1], 0),   purple: idx(MID3[2], 0) };
  const HUMAN_GATE_SET = new Set(Object.values(HUMAN_GATES));
  const CPU_GATE_SET   = new Set(Object.values(CPU_GATES));

  function gateFor(pid){
    const p = PIECES.find(p=>p.id===pid);
    if(!p || p.shape==='blocker') return null;
    const color = SHAPE_TO_COLOR[p.shape];
    return p.side==='H'? HUMAN_GATES[color] : CPU_GATES[color];
  }

  // Pieces definition (4 per side): circle, square, triangle, blocker(diamond)
  const PIECES = [
    {id:'H_CIR', side:'H', shape:'circle'},
    {id:'H_SQ',  side:'H', shape:'square'},
    {id:'H_TRI', side:'H', shape:'triangle'}, // king-like; on cooldown only backward (3 dirs); backward capture -> send to start
    {id:'H_BLK', side:'H', shape:'blocker'},

    {id:'C_CIR', side:'C', shape:'circle'},
    {id:'C_SQ',  side:'C', shape:'square'},
    {id:'C_TRI', side:'C', shape:'triangle'},
    {id:'C_BLK', side:'C', shape:'blocker'}
  ];

  // Starting positions (spread top/right)
  const startPos = {
    H_CIR: idx(0,1), H_SQ: idx(0,2), H_TRI: idx(0,3), H_BLK: idx(0,4),
    C_CIR: idx(1,5), C_SQ: idx(2,5), C_TRI: idx(3,5), C_BLK: idx(4,5)
  };

  const state = {
    pos: Object.fromEntries(PIECES.map(p=>[p.id, startPos[p.id]])),
    turn: 'H',
    last: {H:null, C:null}, // for non-blocker cooldown ("can't move same piece twice in a row")
    blockerCooldown: {H:0, C:0}, // imposed when opponent relocates your blocker off a gate
    history: new Map(),
    over: false,
    exitGate: Object.fromEntries(PIECES.map(p=>[p.id, null])), // where it exited
    moveNum: 0 // total half-moves made
  };

  const pieceEl = Object.fromEntries(PIECES.map(p=>[p.id, mkPiece(p)]));

  // ====== RENDER ======
  function mkPiece(p){
    const el = document.createElement('div');
    el.className = `piece ${p.side==='H'?'human':'cpu'} shape-${p.shape==='blocker'?'diamond':p.shape}`;
    el.setAttribute('role','button');
    el.setAttribute('aria-label', `${p.side==='H'?'Human':'CPU'} ${p.shape}`);
    boardEl.appendChild(el);
    el.addEventListener('click', ()=>{
      if(state.over) return;
      if(state.turn!=='H') return; // human acts only on human turn
      if(p.side==='H'){
        if(state.pos[p.id]!==null) highlightSelection(p.id, 'H', false);
        return;
      }
      if(p.id==='C_BLK' && cpuBlockerOnHumanGate()){
        highlightSelection('C_BLK', 'H', true);
      }
    });
    return el;
  }

  function placePieceElement(el, i){
    const cell = cells[i];
    el.style.left = (cell.offsetLeft + 6) + 'px';
    el.style.top  = (cell.offsetTop  + 6) + 'px';
    el.style.width = `calc(var(--cell) - 12px)`;
    el.style.height= `calc(var(--cell) - 12px)`;
  }

  function placeHomeElement(el, gateIndex){
    const [r,c] = toRC(gateIndex);
    const cell = cells[gateIndex];
    const pieceW = (boardEl.clientWidth/6) - 12;
    let left = cell.offsetLeft + 6;
    let top  = cell.offsetTop  + 6;
    if(r===N-1){ top = cell.offsetTop + (boardEl.clientHeight/6) + 12; }
    else if(c===0){ left = cell.offsetLeft - pieceW - 12; }
    el.style.left = left + 'px';
    el.style.top  = top  + 'px';
    el.style.width = `calc(var(--cell) - 12px)`;
    el.style.height= `calc(var(--cell) - 12px)`;
  }

  function render(){
    PIECES.forEach(p=>{
      const el = pieceEl[p.id];
      const i = state.pos[p.id];
      const gateIdx = state.exitGate[p.id];
      if(i===null && gateIdx!==null){
        el.classList.add('home');
        placeHomeElement(el, gateIdx);
        el.style.display = 'block';
      } else if(i!==null){
        el.classList.remove('home');
        placePieceElement(el, i);
        el.style.display = 'block';
      } else {
        el.style.display = 'none';
      }
    });
    buildCoords();
  }

  function showToast(msg, ms=1200){ toastEl.textContent=msg; toastEl.classList.add('show'); setTimeout(()=>toastEl.classList.remove('show'), ms); }

  function addStartLine(side){
    const line = document.createElement('div'); line.className='mv';
    const who = document.createElement('span'); who.className='who'; who.textContent = 'Start';
    const path = document.createElement('span'); path.className='path'; path.textContent = side==='H' ? 'Human' : 'CPU';
    line.appendChild(who); line.appendChild(path); movesEl.appendChild(line); movesEl.scrollTop = movesEl.scrollHeight;
  }

  function addMoveLine({side, pid, from, to, kind, oppControl, note}){
    const p = PIECES.find(x=>x.id===pid);
    const line = document.createElement('div'); line.className='mv';
    const sym = document.createElement('span'); sym.className=`sym ${side==='H'?'h':'c'}`; sym.textContent = SHAPE_SYM[p.shape];
    const who = document.createElement('span'); who.className='who'; who.textContent = side==='H'?'H':'CPU';
    const path = document.createElement('span'); path.className='path';
    if(kind==='off') path.textContent = `${coord(from)} → OFF`;
    else path.textContent = `${coord(from)} → ${coord(to)}` + (oppControl? ' (opp blocker)' : '');
    if(note){ const n=document.createElement('span'); n.style.marginLeft='6px'; n.style.color='#a7f3d0'; n.textContent = `• ${note}`; line.appendChild(n); }
    line.appendChild(sym); line.appendChild(who); line.appendChild(path);
    movesEl.appendChild(line);
    movesEl.scrollTop = movesEl.scrollHeight;
  }

  function positionKey(){
    const arr = PIECES.map(p=> state.pos[p.id]===null? 'x' : String(state.pos[p.id]));
    return [arr.join(','), state.turn, state.last.H||'_', state.last.C||'_', state.blockerCooldown.H||0, state.blockerCooldown.C||0].join('|');
  }
  function updateHistory(){ const k=positionKey(); state.history.set(k,(state.history.get(k)||0)+1); }
  function threefold(){ const k=positionKey(); return (state.history.get(k)||0)>=3; }

  function reset(){
    Object.keys(state.pos).forEach(id=> state.pos[id]=startPos[id]);
    state.last={H:null,C:null}; state.blockerCooldown={H:0,C:0}; state.history=new Map(); state.over=false; state.moveNum=0;
    state.exitGate = Object.fromEntries(PIECES.map(p=>[p.id, null]));
    state.turn = Math.random() < 0.5 ? 'H' : 'C';
    offBtn.style.display='none'; clearHighlights(); movesEl.innerHTML=''; render();
    addStartLine(state.turn);
    updateHistory();
    if(state.turn==='C') setTimeout(cpuTurn, 350);
  }

  // ====== RULES ======
  function piecesOnBoard(side){ return PIECES.filter(p=>p.side===side && p.shape!=='blocker' && state.pos[p.id]!==null).length; }
  function onCooldown(pid){
    const p = PIECES.find(x=>x.id===pid); if(!p) return false; if(p.shape==='blocker') return false;
    const count = piecesOnBoard(p.side);
    if(count<=1) return false; // waive cooldown if it's the last non-blocker piece
    return state.last[p.side] === pid;
  }

  function canExit(pid){
    const p = PIECES.find(x=>x.id===pid);
    if(!p || p.shape==='blocker') return false;
    if(onCooldown(pid)) return false; // cannot exit on cooldown
    const gate = gateFor(pid);
    return gate!==null && state.pos[pid]===gate;
  }

  function cellOccupied(i){ return PIECES.some(p=> state.pos[p.id]===i ); }

  function isOpponentGateFor(side, i){ return side==='H'? CPU_GATE_SET.has(i) : HUMAN_GATE_SET.has(i); }
  function isOwnPieceAt(side, i){ const pid = findPieceAt(i); if(!pid) return false; return pid.startsWith(side+'_'); }

  // Backward now includes three directions
  function isBackwardMove(side, from, to){
    const [r,c]=toRC(from), [nr,nc]=toRC(to);
    if(side==='H') return (nr===r-1 && (nc===c-1 || nc===c || nc===c+1));
    return (nc===c+1 && (nr===r-1 || nr===r || nr===r+1));
  }

  function humanTriangleNeighbors(i){
    const [r,c]=toRC(i); const nn=[];
    for(let dr=-1; dr<=1; dr++) for(let dc=-1; dc<=1; dc++){
      if(dr===0 && dc===0) continue; const nr=r+dr, nc=c+dc; if(inBounds(nr,nc)){ const di=idx(nr,nc); if(!isOpponentGateFor('H', di)) nn.push(di); }
    }
    return nn;
  }
  function cpuTriangleNeighbors(i){
    const [r,c]=toRC(i); const nn=[];
    for(let dr=-1; dr<=1; dr++) for(let dc=-1; dc<=1; dc++){
      if(dr===0 && dc===0) continue; const nr=r+dr, nc=c+dc; if(inBounds(nr,nc)){ const di=idx(nr,nc); if(!isOpponentGateFor('C', di)) nn.push(di); }
    }
    return nn;
  }

  // Human non-blockers (except triangle): no north; CPU non-blockers (except triangle): no east.
  // Non-blockers may NOT enter opponent gate cells. Only blockers may.
  function legalHumanMovesOwn(pid){
    const p = PIECES.find(x=>x.id===pid); const i=state.pos[pid]; if(i===null) return [];
    if(p.shape==='blocker'){
      if(state.blockerCooldown['H']>0) return [];
      const all=[]; for(let j=0;j<N*N;j++){ if(j!==i && !cellOccupied(j)) all.push(j); } return all;
    }
    if(p.shape==='triangle'){
      if(onCooldown(pid)){
        // backward 1 in three directions; may capture opponent; may NOT land on opponent gate; may not land on own piece
        const [r,c]=toRC(i); const cands=[[r-1,c-1],[r-1,c],[r-1,c+1]]; const out=[];
        for(const [nr,nc] of cands){ if(inBounds(nr,nc)){ const di=idx(nr,nc); if(!isOpponentGateFor('H', di) && !isOwnPieceAt('H', di)) out.push(di); }}
        return out;
      } else {
        // king-like one step, empty only, any direction, except opponent gates
        return humanTriangleNeighbors(i).filter(di=> !cellOccupied(di) );
      }
    }
    // circle/square as before
    if(onCooldown(pid)) return [];
    const [r,c]=toRC(i); const dests=[];
    const cands=[[r+1,c],[r,c+1],[r,c-1]];
    for(const [nr,nc] of cands){ if(inBounds(nr,nc)){ const di=idx(nr,nc); if(!cellOccupied(di) && !CPU_GATE_SET.has(di)) dests.push(di); }}
    return dests;
  }

  function legalCpuMovesOwn(pid){
    const p = PIECES.find(x=>x.id===pid); const i=state.pos[pid]; if(i===null) return [];
    if(p.shape==='blocker'){
      if(state.blockerCooldown['C']>0) return [];
      const all=[]; for(let j=0;j<N*N;j++){ if(j!==i && !cellOccupied(j)) all.push(j); } return all;
    }
    if(p.shape==='triangle'){
      if(onCooldown(pid)){
        // backward 1 in three directions (NE, E, SE); may capture opponent; can't land on opponent gate or own piece
        const [r,c]=toRC(i); const cands=[[r-1,c+1],[r,c+1],[r+1,c+1]]; const out=[];
        for(const [nr,nc] of cands){ if(inBounds(nr,nc)){ const di=idx(nr,nc); if(!isOpponentGateFor('C', di) && !isOwnPieceAt('C', di)) out.push(di); }}
        return out;
      } else {
        return cpuTriangleNeighbors(i).filter(di=> !cellOccupied(di) );
      }
    }
    if(onCooldown(pid)) return [];
    const [r,c]=toRC(i); const dests=[];
    const cands=[[r-1,c],[r+1,c],[r,c-1]];
    for(const [nr,nc] of cands){ if(inBounds(nr,nc)){ const di=idx(nr,nc); if(!cellOccupied(di) && !HUMAN_GATE_SET.has(di)) dests.push(di); }}
    return dests;
  }

  // Opponent can move your blocker ONLY if it's sitting on their gates
  function cpuBlockerOnHumanGate(){ const i = state.pos['C_BLK']; return i!==null && HUMAN_GATE_SET.has(i); }
  function humanBlockerOnCpuGate(){ const i = state.pos['H_BLK']; return i!==null && CPU_GATE_SET.has(i); }

  function legalOppControlBlockerMoves(pid){
    const i = state.pos[pid]; if(i===null) return [];
    const moves=[]; for(let j=0;j<N*N;j++){ if(j!==i && !cellOccupied(j)) moves.push(j); }
    return moves;
  }

  // Return a piece to its start; if start is occupied, pick nearest free square (avoid opponent gates if possible)
  function returnToStart(pid){
    const owner = pid.startsWith('H')?'H':'C';
    const start = startPos[pid];
    const oppGateSet = owner==='H'? CPU_GATE_SET : HUMAN_GATE_SET;
    if(!cellOccupied(start)){ state.pos[pid]=start; return; }
    const order = Array.from({length:N*N}, (_,i)=>i).sort((a,b)=>{
      const da = manhattan(a,start) + (oppGateSet.has(a)?1000:0);
      const db = manhattan(b,start) + (oppGateSet.has(b)?1000:0);
      return da-db;
    });
    for(const i of order){ if(!cellOccupied(i)) { state.pos[pid]=i; return; } }
    state.pos[pid]=null; // fallback
  }

  // ====== INTERACTION ======
  let destOverlays=[];
  function clearHighlights(){ destOverlays.forEach(el=>el.remove()); destOverlays=[]; Object.values(pieceEl).forEach(el=>el.classList.remove('selected')); offBtn.style.display='none'; }
  function spawnRipple(i){
    const r = document.createElement('div'); r.className='ripple';
    const cell = cells[i];
    r.style.left = (cell.offsetLeft + 6) + 'px';
    r.style.top  = (cell.offsetTop  + 6) + 'px';
    r.style.width = `calc(var(--cell) - 12px)`; r.style.height = `calc(var(--cell) - 12px)`;
    boardEl.appendChild(r); setTimeout(()=> r.remove(), 520);
  }

  function highlightSelection(pid, controllerSide, oppControl){
    clearHighlights(); pieceEl[pid] && pieceEl[pid].classList.add('selected');
    const canOff = (!oppControl && canExit(pid));
    const moves = oppControl ? legalOppControlBlockerMoves(pid)
                             : (controllerSide==='H'? legalHumanMovesOwn(pid) : legalCpuMovesOwn(pid));
    for(const di of moves){
      const overlay=document.createElement('div'); overlay.className='dest';
      overlay.style.left=cells[di].offsetLeft+6+'px'; overlay.style.top=cells[di].offsetTop+6+'px';
      overlay.style.width=`calc(var(--cell) - 12px)`; overlay.style.height=`calc(var(--cell) - 12px)`;
      overlay.addEventListener('click',()=> makeMove(pid, di, 'step', controllerSide, oppControl));
      boardEl.appendChild(overlay); destOverlays.push(overlay);
    }
    if(canOff){
      const cell=cells[state.pos[pid]]; const [r,c]=toRC(state.pos[pid]);
      offBtn.style.display='block'; let x=cell.offsetLeft+8, y=cell.offsetTop-44;
      if(r===N-1) y=cell.offsetTop+8+(parseFloat(getComputedStyle(cell).height)||0);
      if(c===0) { x=cell.offsetLeft-60; y=cell.offsetTop+8; }
      offBtn.style.left=x+'px'; offBtn.style.top=y+'px'; offBtn.onclick=()=> makeMove(pid, null, 'off', controllerSide, false);
    }
  }

  function makeMove(pid, dest, kind, controllerSide, oppControl){
    if(state.over) return;
    const ownerSide = pid.startsWith('H')? 'H':'C';
    const from = state.pos[pid];

    if(controllerSide==='C'){
      const el = pieceEl[pid]; if(el) { el.classList.add('cpu-anim'); setTimeout(()=> el.classList.remove('cpu-anim'), 360); }
    }

    if(kind==='off'){
      if(oppControl){ showToast('Illegal OFF'); return; }
      if(!canExit(pid)){ showToast('Illegal OFF'); return; }
      const gateIdx = gateFor(pid);
      state.pos[pid]=null; state.exitGate[pid]=gateIdx;
      addMoveLine({side:controllerSide, pid, from, to:gateIdx, kind:'off', oppControl:false});
      if(controllerSide==='C') spawnRipple(gateIdx);
      if(controllerSide===ownerSide) state.last[controllerSide]=pid;
    } else if(kind==='step'){
      let legal = [];
      if(oppControl){
        if(!( (controllerSide==='H' && cpuBlockerOnHumanGate() && pid==='C_BLK') || (controllerSide==='C' && humanBlockerOnCpuGate() && pid==='H_BLK') )){
          showToast('Illegal move'); return;
        }
        legal = legalOppControlBlockerMoves(pid);
      } else {
        legal = (controllerSide==='H')? legalHumanMovesOwn(pid) : legalCpuMovesOwn(pid);
      }
      if(!legal.includes(dest)){ showToast('Illegal move'); return; }

      // Triangle special: backward capture to start
      let note=null; const movingPiece = PIECES.find(x=>x.id===pid);
      const occ = findPieceAt(dest);
      const isTriBackCap = (movingPiece.shape==='triangle' && controllerSide===ownerSide && onCooldown(pid) && isBackwardMove(ownerSide, from, dest) && occ && !occ.startsWith(ownerSide+'_'));
      state.pos[pid]=dest;
      if(isTriBackCap){ returnToStart(occ); note = `send ${occ} to start`; }

      addMoveLine({side:controllerSide, pid, from, to:dest, kind:'step', oppControl:!!oppControl, note});
      if(controllerSide==='C') spawnRipple(dest);
      if(oppControl){ state.blockerCooldown[ownerSide] = 1; }
      if(!oppControl && controllerSide===ownerSide) state.last[controllerSide]=pid;
    }

    clearHighlights(); render(); if(checkGameEnd()) return;
    endOfTurn(controllerSide);
    state.turn = (state.turn==='H')?'C':'H';
    state.moveNum += 1;
    updateHistory();
    if(state.turn==='C') setTimeout(cpuTurn, 260);
  }

  function endOfTurn(side){ if(state.blockerCooldown[side]>0) state.blockerCooldown[side] -= 1; }

  function sideWon(side){
    const need = PIECES.filter(p=>p.side===side && p.shape!=='blocker');
    return need.every(p=> state.pos[p.id]===null );
  }
  function checkGameEnd(){
    if(sideWon('H')){ endGame('Human wins by exiting all non-blocker pieces.'); return true; }
    if(sideWon('C')){ endGame('CPU wins by exiting all non-blocker pieces.'); return true; }
    if(threefold()){ endGame('Draw by threefold repetition.'); return true; }
    return false;
  }
  function endGame(msg){ state.over=true; showToast(msg, 1800); }

  // ====== CPU & AI ======
  // Stronger search: depth-4 iterative deepening with alpha-beta, beam ordering,
  // transposition table, killer-move ordering, and light randomness to avoid
  // deterministic play. Time-bounded per move.
  const AI = { MAX_DEPTH: 4, TIME_MS: 140, BEAM: 14 };
  const TT = new Map(); // transposition table
  const killers = Array.from({length: 16}, ()=> []); // killer moves per ply

  function jitter(range=0.2){ return (Math.random()*2-1)*range; }

  function moveToKey(o){
    if(!o) return '';
    return [o.pid,o.kind,o.dest??'off',o.oppControl?1:0,o.controller].join(':');
  }

  function enumerateSideOptions(side){
    const opts=[];
    const canOppMoveBlocker = side==='H' ? cpuBlockerOnHumanGate() : humanBlockerOnCpuGate();
    if(canOppMoveBlocker){
      const pid = side==='H'? 'C_BLK' : 'H_BLK';
      const mv = legalOppControlBlockerMoves(pid);
      for(const d of mv){ opts.push({pid, kind:'step', dest:d, controller:side, oppControl:true}); }
    }
    for(const p of PIECES.filter(p=>p.side===side)){
      const id=p.id; const i=state.pos[id]; if(i===null) continue;
      if(canExit(id)) { opts.push({pid:id, kind:'off', controller:side, oppControl:false}); continue; }
      const moves = side==='H'? legalHumanMovesOwn(id) : legalCpuMovesOwn(id);
      for(const d of moves){ opts.push({pid:id, kind:'step', dest:d, controller:side, oppControl:false}); }
    }
    return opts;
  }

  function evalForCpu(){
    // Higher is better for CPU
    let cpuProgress = 0, humProgress = 0, mobility=0, cdPain=0, laneClash=0;
    for(const shp of ['CIR','SQ','TRI']){
      const cpid='C_'+shp, hpid='H_'+shp;
      if(state.pos[cpid]!==null){ cpuProgress += (10 - Math.min(10, manhattan(state.pos[cpid], gateFor(cpid))));
        mobility += (enumerateSideOptions('C').length/20); // rough mobility proxy
        if(onCooldown(cpid)) cdPain -= 0.6; }
      if(state.pos[hpid]!==null){ humProgress += (10 - Math.min(10, manhattan(state.pos[hpid], gateFor(hpid))));
        if(onCooldown(hpid)) cdPain += 0.4; }
    }
    // discourage piling on same file for CPU pieces (simple lane clash)
    const files = new Map();
    for(const id of ['C_CIR','C_SQ','C_TRI']){ if(state.pos[id]!==null){ const [,c]=toRC(state.pos[id]); files.set(c,(files.get(c)||0)+1); }}
    for(const v of files.values()){ if(v>1) laneClash -= (v-1)*0.6; }

    let score = (cpuProgress - humProgress) + mobility + cdPain + laneClash;
    if(cpuBlockerOnHumanGate()) score += 6; // gate control
    if(humanBlockerOnCpuGate()) score -= 8;
    const hThreat = imminentHumanGateThreat(); if(hThreat!==null) score -= 10;
    if(state.moveNum < 6){ // early development
      for(const id of ['C_SQ','C_CIR']){ if(state.pos[id]!==null && state.pos[id]!==startPos[id]) score += 1.5; }
    }
    return score + jitter(0.15);
  }

  function snapshotState(){
    return { pos: {...state.pos}, turn: state.turn, last: {...state.last}, blockerCooldown: {...state.blockerCooldown}, over: state.over, exitGate: {...state.exitGate}, moveNum: state.moveNum };
  }
  function restoreStateSnapshot(snap){
    state.pos = {...snap.pos}; state.turn = snap.turn; state.last = {...snap.last}; state.blockerCooldown = {...snap.blockerCooldown}; state.over = snap.over; state.exitGate = {...snap.exitGate}; state.moveNum = snap.moveNum;
  }

  function applyOptionToState(o){
    const owner = o.pid.startsWith('H')? 'H':'C';
    if(o.kind==='off'){
      const gate = gateFor(o.pid); state.pos[o.pid]=null; state.exitGate[o.pid]=gate; if(o.controller===owner) state.last[o.controller]=o.pid;
    } else {
      const from = state.pos[o.pid]; state.pos[o.pid]=o.dest; if(o.oppControl){ state.blockerCooldown[owner]=1; } if(o.controller===owner) state.last[o.controller]=o.pid;
      // triangle backward capture in simulation too
      const movingPiece = PIECES.find(x=>x.id===o.pid);
      if(movingPiece.shape==='triangle' && o.controller===owner && onCooldown(o.pid) && isBackwardMove(owner, from, o.dest)){
        const occ = findPieceAt(o.dest); if(occ && !occ.startsWith(owner+'_')){ returnToStart(occ); }
      }
    }
    state.turn = (state.turn==='H')?'C':'H'; state.moveNum += 1;
  }

  function shallowScore(o, side){
    // quick approximate value to order moves
    const owner = o.pid.startsWith('H')? 'H':'C';
    if(o.kind==='off') return side==='C'? 1200 : -1200;
    // triangle backward capture gets a boost
    if(o.pid==='C_TRI' && side==='C' && onCooldown('C_TRI') && isBackwardMove('C', state.pos['C_TRI'], o.dest)){
      const occ = findPieceAt(o.dest); if(occ && occ.startsWith('H_')) return 800;
    }
    if(o.pid==='H_TRI' && side==='H' && onCooldown('H_TRI') && isBackwardMove('H', state.pos['H_TRI'], o.dest)){
      const occ = findPieceAt(o.dest); if(occ && occ.startsWith('C_')) return -700; // dangerous for CPU
    }
    const gate = gateFor(o.pid);
    if(gate!==null){
      const d0 = manhattan(state.pos[o.pid], gate);
      const d1 = manhattan(o.dest ?? state.pos[o.pid], gate);
      const delta = d0 - d1; return (owner==='C'? 11: -11) * delta;
    }
    if(o.pid==='C_BLK'){ return HUMAN_GATE_SET.has(o.dest) ? 8 : 0; }
    return 0;
  }

  function ttKey(depth, side){ return positionKey()+`|d${depth}|${side}`; }

  function alphaBeta(depth, alpha, beta, sideToMove, ply, deadline){
    if(performance.now() > deadline){ return {val: evalForCpu(), cutoff:true}; }
    if(depth===0){ return {val: evalForCpu(), cutoff:false}; }
    if(sideWon('C')) return {val: 1e6, cutoff:false};
    if(sideWon('H')) return {val:-1e6, cutoff:false};

    const key = ttKey(depth, sideToMove);
    if(TT.has(key)){ const e=TT.get(key); if(e.depth>=depth) return {val:e.val, cutoff:false}; }

    // generate & order
    let moves = enumerateSideOptions(sideToMove);
    const ordered = moves.map(o=> ({o, s: shallowScore(o, sideToMove)}));
    // killer heuristic
    const ks = killers[ply] || [];
    for(const k of ks){ const i = ordered.findIndex(x=> moveToKey(x.o)===k); if(i>0){ const t=ordered[i]; ordered.splice(i,1); ordered.unshift(t); } }
    ordered.sort((a,b)=> sideToMove==='C' ? b.s - a.s : a.s - b.s);
    const beam = ordered.slice(0, AI.BEAM).map(x=>x.o);

    if(sideToMove==='C'){
      let best = -Infinity; let bestMove=null;
      for(const m of beam){ const snap=snapshotState(); applyOptionToState(m); const res=alphaBeta(depth-1, alpha, beta, 'H', ply+1, deadline); restoreStateSnapshot(snap); if(res.cutoff) return {val:res.val, cutoff:true}; const val=res.val; if(val>best){ best=val; bestMove=m; } if(best>alpha) alpha=best; if(alpha>=beta){ // beta cutoff
          killers[ply] = [moveToKey(m), ...(killers[ply]||[])].slice(0,2);
          break; }
      }
      TT.set(key,{val:best, depth});
      return {val:best, move:bestMove, cutoff:false};
    } else {
      let best = Infinity; let bestMove=null;
      for(const m of beam){ const snap=snapshotState(); applyOptionToState(m); const res=alphaBeta(depth-1, alpha, beta, 'C', ply+1, deadline); restoreStateSnapshot(snap); if(res.cutoff) return {val:res.val, cutoff:true}; const val=res.val; if(val<best){ best=val; bestMove=m; } if(best<beta) beta=best; if(alpha>=beta){ killers[ply] = [moveToKey(m), ...(killers[ply]||[])].slice(0,2); break; }
      }
      TT.set(key,{val:best, depth});
      return {val:best, move:bestMove, cutoff:false};
    }
  }

  function cpuTurn(){
    if(state.over) return;

    // A) If human blocker is on a CPU gate, relocate it far away immediately.
    if(humanBlockerOnCpuGate()){
      const moves = legalOppControlBlockerMoves('H_BLK');
      const scored = moves.map(d=>({d,score:scoreCpuOppBlockerMove(d)})).sort((a,b)=>b.score-a.score).slice(0,18);
      if(scored.length){ const best = scored[0]; makeMove('H_BLK', best.d, 'step', 'C', true); return; }
    }

    // B) Triangle backward-capture priority (three directions)
    const triId = 'C_TRI'; const triPos = state.pos[triId];
    if(triPos!==null && onCooldown(triId)){
      const [r,c]=toRC(triPos); const cands=[[r-1,c+1],[r,c+1],[r+1,c+1]];
      for(const [nr,nc] of cands){ if(inBounds(nr,nc)){
        const di=idx(nr,nc); const occ = findPieceAt(di);
        if(!isOpponentGateFor('C', di) && occ && occ.startsWith('H_')){ makeMove(triId, di, 'step', 'C', false); return; }
      }}
    }

    // C) Build candidate root options with throttled blocker behavior
    let options=[];
    for(const p of PIECES.filter(p=>p.side==='C')){
      const id=p.id; const i=state.pos[id]; if(i===null) continue;
      if(canExit(id)) { options.push({pid:id, kind:'off', controller:'C', oppControl:false}); continue; }
      if(id==='C_BLK'){
        const moves = legalCpuMovesOwn(id);
        const threatGateNow = imminentHumanGateThreat();
        const cblkPos = state.pos['C_BLK'];
        const onHumanGate = (cblkPos!==null && HUMAN_GATE_SET.has(cblkPos));
        let filtered = [];
        if(threatGateNow!==null){ if(moves.includes(threatGateNow)) filtered = [threatGateNow]; }
        else if(!onHumanGate){ filtered = moves.filter(d=> HUMAN_GATE_SET.has(d)); if(state.moveNum < 2 && Math.random()<0.5) filtered = []; }
        for(const d of filtered){ options.push({pid:id, kind:'step', dest:d, controller:'C', oppControl:false}); }
        continue; // no roaming blocker
      }
      const moves = legalCpuMovesOwn(id);
      for(const d of moves){ options.push({pid:id, kind:'step', dest:d, controller:'C', oppControl:false}); }
    }

    if(options.length===0){ endGame('Draw: CPU has no legal moves.'); return; }

    // D) Iterative deepening search with time budget
    const start = (performance.now?performance.now():Date.now());
    const deadline = start + AI.TIME_MS;
    TT.clear(); killers.forEach((_,i)=> killers[i]=[]);

    let bestOverall = null; let bestVal = -Infinity; let depthReached = 1;
    // light shuffle to avoid deterministic ties
    options.sort(()=> Math.random()-0.5);

    for(let d=2; d<=AI.MAX_DEPTH; d++){
      let localBest = null; let localBestVal = -Infinity;
      for(const o of options){
        const snap=snapshotState(); applyOptionToState(o);
        const res = alphaBeta(d-1, -Infinity, Infinity, 'H', 0, deadline);
        restoreStateSnapshot(snap);
        if(res.cutoff){ break; }
        const v = res.val;
        if(v>localBestVal + 1e-9){ localBestVal=v; localBest=o; }
        else if(Math.abs(v-localBestVal) < 0.15 && Math.random()<0.35){ localBest=o; localBestVal=v; }
      }
      if(localBest){ bestOverall = localBest; bestVal = localBestVal; depthReached = d; }
      if((performance.now?performance.now():Date.now()) > deadline) break;
    }

    const chosen = bestOverall || options[0];
    makeMove(chosen.pid, chosen.dest ?? null, chosen.kind, chosen.controller, chosen.oppControl);
  }

  function nearestThreatenedHumanGateInfo(){
    let best = null;
    for(const shp of ['CIR','SQ','TRI']){
      const pid = 'H_'+shp; if(state.pos[pid]===null) continue; const gate = gateFor(pid); const d = manhattan(state.pos[pid], gate); if(best===null || d<best.dist){ best = {pid, gate, dist:d}; }
    }
    return best;
  }

  function imminentHumanGateThreat(){
    for(const shp of ['CIR','SQ','TRI']){
      const pid = 'H_'+shp; if(state.pos[pid]===null) continue; const gate = gateFor(pid); const legal = legalHumanMovesOwn(pid); if(legal.includes(gate) && !cellOccupied(gate)) return gate; }
    return null;
  }

  function scoreCpuOppBlockerMove(dest){ let s = 0; if(CPU_GATE_SET.has(dest)) s -= 2000; let sum=0; for(const g of Object.values(CPU_GATES)){ sum += manhattan(dest,g); } s += sum*20; return s; }

  // ====== WIRES ======
  resetBtn.addEventListener('click', reset);
  window.addEventListener('resize', ()=>{ render(); clearHighlights(); });

  // initial render
  render();
  reset();
})();
</script>
</body>
</html>
